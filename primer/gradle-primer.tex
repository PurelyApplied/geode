 \documentclass[]{article}

\usepackage[total={7in, 9in}]{geometry}
\usepackage{hyperref}  % clicky-links
\usepackage[utf8]{inputenc}  % language support
\usepackage[english]{babel}  % language support
\usepackage{listings} % enables lstlisting for code blocks.
\usepackage{amsthm}  % \newtheorem*
\usepackage{framed} % \begin{framed}

\usepackage{newfloat}
\DeclareFloatingEnvironment[
    listname={List of Snippets},
    name=Snippet,
    placement=tbhp,
%    within=section,
]{snippet}

\usepackage[framestyle=fbox,framefit=yes,heightadjust=all,framearound=all]{floatrow}  % Put a box around every figure or table

\theoremstyle{definition}
\newtheorem*{tip}{Protip}

\usepackage{xcolor} % \definecolor

%%%%%
%% Define groovy highlighting, from https://buergel.es/index.php/articles/latex-listings-groovy-aspectj.html
%% Added here:
%%  showstringspaces=false,
%%  commentstyle=\color{gray}\ttfamily,
%%  morekeywords={...}
\definecolor{groovyblue}{HTML}{0000A0}
\definecolor{groovygreen}{HTML}{008000}
\definecolor{darkgray}{rgb}{.4,.4,.4}

\lstdefinelanguage{Groovy}[]{Java}{
  keywordstyle=\color{groovyblue}\bfseries,
  stringstyle=\color{groovygreen}\ttfamily,
  keywords=[3]{each, findAll, groupBy, collect, inject, eachWithIndex},
  showstringspaces=false,
  commentstyle=\color{gray}\ttfamily,
  morekeywords={def, as, in, use, tasks, inputs, outputs},
  moredelim=[is][\textcolor{darkgray}]{\%\%}{\%\%},
  moredelim=[il][\textcolor{darkgray}]{§§}
}
%%%%%%
\title{Building a working \texttt{./gradlew build}  \large \\
  A collection of best practices, pain points, and tricks \\
  that I hard to learn the hard way}

\author{Patrick S. Rhomberg,\\ a.k.a. GitHub user \texttt{PurelyApplied}}


\newcommand{\startSnippetFig}{%
\begin{snippet}
  \begin{minipage}[c]{.9\textwidth}
    \begin{framed}
}
\newcommand{\stopSnippetFig}{%
    \end{framed}
  \end{minipage}
\end{snippet}
}

\begin{document}

\maketitle
\tableofcontents

\listofsnippets
\newpage

\section{Introduction and disclaimer}

Pretend this is a dev blog.
I intend, in fact, to upload this to a personal dev blog.
Remember read this with that mentality.
Despite the nice presentation that comes from my love of \LaTeX, 
this is really just a haphazard collection of things I subjectively consider important for someone trying to ramp up or stabilize their Gradle build.

Some things are initially presented in the "easy to think this way that is a little bit wrong."
I footnote these with the correction.
This document is meant to be educational, not necessarily as a concise reference, and the path to understanding is rarely direct.
I know it can seem misleading, particularly to people who are technically inclined, but here we are.

I learned Gradle the proverbial Hard Way while revamping a legacy build into something parallelizable, correct, and consistent.%
\footnote{Or at least, \emph{more} parallelizable, correct, and consistent.}
It expects a passing familarity but not a comprehensive understanding.
This is for people trying to understand their Gradle build,
  not necessarily for someone trying to write a new one.


\section{Groovy crash course}

Groovy feels like Java's side-hustle moonlighting as a scripting language.
It is much more permissive than Java is,
  which can be freeing at times and can feel like more than enough rope at others.
If you want an actual syntax-and-such crash course, I encourage you to read the docs.%
\footnote{\url{http://groovy-lang.org/documentation.html}}
Alternatively, I'm a personal fan of Learn X in Y Minutes.%
\footnote{\url{https://learnxinyminutes.com/docs/groovy/}}

The things I mention here have more to do with what you might find confusing or counter-intuitive.

\subsection{Functions don't require parentheses}

Something that can be initially confusing is the fact that Groovy can accept function parameters
  without parentheses.
See Snippet \ref{snip:hello-parens} for an explcit example.
This is true even for functions that accept more than one argument,
  although in this case parentheses often improve readability.
Also, nesting function calls \emph{does} require parentheses.


\startSnippetFig
\begin{lstlisting}[language=Groovy]
println "Hello world!"
// is equivalent to
println("Hello world!")


def add(int x, int y) {
  return x + y
}

def z = add(1, 2)
// is equivalent to
def z = add 1, 2
\end{lstlisting}
\caption{Parentheses are often optional in Groovy.}
\label{snip:hello-parens}
\stopSnippetFig

As we'll see in a moment, there is a lot of wiggle room when it comes to parentheses
  and how arguments are passed to Groovy functions.
This is particularly true when it comes to closures.
''But what are closures?'' I hear you cry...

\subsection{Closures}
\textit{Closures} are the Big Hotness in Groovy.
You can start off by thinking of a closure as a super-lambda.%
\footnote{While this is absolutely incorrect, it's a reasonable starting point that we will correct in a moment.
  As we'll see, closures are first-class objects and have the advantage of being able to be configured after instantiation in ways that Java lambdas do not.
  See\ \url{http://groovy-lang.org/closures.html\#\_groovy_closures_vs_lambda_expressions} for details.}
Closures are ubiquitous in Gradle because they're a wonderful way to specify configuration as a parameter, in a reasonably readable and intuitive way.

Closures look like (and really \emph{are}) an arbitrary code block.
They're offset by squiggly-braces, like any function definition or \texttt{for} loop block.

Closures often have an implicit parameter of \texttt{it}.
See Snippet \ref{snip:implicit-params} for a trivial example.

\startSnippetFig
\begin{lstlisting}[language=Groovy]
def greeting1 = { "Hello, $it!" }
def greeting2 = { it -> "Hello, $it!" }
def greeting3 = { name -> "Hello, $name!" }
assert greeting1("Patrick") == "Hello, Patrick!"
assert greeting2("Patrick") == "Hello, Patrick!"
assert greeting3("Patrick") == "Hello, Patrick!"
\end{lstlisting}
\caption{Closure can explicitly define parameters, or otherwise have the implicit parameter \texttt{it}.}
\label{snip:implicit-params}
\stopSnippetFig

\subsection{More than super-lambdas}
\label{sec:super-lambdas}
The real power of closures comes from \emph{delegate injection}.
Unlike a Java lambda, closures are [TODO WORDS]

\startSnippetFig
\begin{lstlisting}[language=Groovy]
class MyStringContainer {
  private myString

  MyStringContainer(String s) {
    myString = s
  }

  String getMyString(){
    println "In getter"
    return myString
  }

  String setMyString(String s){
    println "In setter"
    myString = s
  }


  String plus(String s){
    return myString + s
  }
}
\end{lstlisting}
    \caption{We will use this simple class in many of the subsequent examples.}
    \label{snip:container}
\stopSnippetFig


Consider the following function which takes a \texttt{MyStringContainer} and a closure.

\startSnippetFig
\begin{lstlisting}[language=Groovy]
String myFunc(MyStringContainer container,
              Closure someClosure){
  cl.delegate = container
  return someClosure()
}

println myFunc(new MyStringContainer("Hello"), {
  plus " world!"
})
\end{lstlisting}
\caption{boo}
\label{snip:boo}
\stopSnippetFig

This snippet will print \texttt{Hello world!}  [TODO explain why]

\subsection{Syntactic sugar}
\subsubsection{Setters are getters}

Setters and getters are boring.
Groovy doesn't make you use them.
Consider Snippet \ref{snip:get-set}

The following are equivalent.

\startSnippetFig
\begin{lstlisting}[language=Groovy]
// In the Java-style
MyStringContainer x = new MyStringContainer("foo")
println(x.getMyString())
x.setMyString("bar")
println(x.getMyString())

// Equivalent function calls in the Groovy style
def x = new MyStringContainer("foo")
println x.myString
x.myString = "bar"
println x.myString
\end{lstlisting}
\caption{Groovy uses setters and getters but adopts a more direct syntax.}
\label{snip:get-set}
\stopSnippetFig

Note that if you run this locally, you \emph{do} get
  the \texttt{"In setter"} and \texttt{"In getter"} prints in both cases.

\subsubsection{Playing fast and loose with parentheses return values}

Let us consider again the snippet from Section \ref{sec:super-lambdas}.
In Snippet \ref{snip:return-values}, we see two bits of syntactic sugar.

\startSnippetFig
The following are equivalent:

\hrule
\begin{lstlisting}[language=Groovy]
String myFunc(MyStringContainer container,
              Closure someClosure){
  cl.delegate = container
  return someClosure()
}

println myFunc(new MyStringContainer("Hello"), {
  plus " world!"
})
\end{lstlisting}

\hrule
\begin{lstlisting}[language=Groovy]
String myFunc(MyStringContainer container,
              Closure someClosure){
  cl.delegate = container
  someClosure()  // <- no explicit return
}

//                note paren placement here  |
//                                           V
println myFunc(new MyStringContainer("Hello")) {
  plus " world!"
}    // <- not here
\end{lstlisting}
\hrule\smallskip

In either case, \texttt{"Hello world!"} is printed.

\caption{Final closure arguments can be passed after a closing function-call's parentheses, and return values need not be explicitly declared.}
\label{snip:return-values}
\stopSnippetFig

Groovy does not require an explicit \texttt{return},
  and in its absence, will return the value of the last line called.
Also, Groovy will allow you to close the paren before the last argument of a function if that
  final argument is a closure.
As such, the following snippet is equivalent to the above.

\subsubsection{Corollary: What seems like keywords are actually function calls}

Consider the code presented in Snippet \ref{snip:keywords}, pulled from Apache Geode's build.
In this snippet, we declare a task of type \texttt{Jar} and configure it.

It might initially seem like a convoluted markup language,
  only marginally better than hand-crafting an XML that will be parsed out by our builder.
Knowing the concepts presented above, however, we can see that it is a culmination of
  syntactic sugar and closure delegation.
In my own learning of Groovy and Gradle, realizing this did a great deal to demystify the
  code I was attempting to improve.

\startSnippetFig
  \begin{lstlisting}[language=Groovy]
// From apache/geode.git/geode-assembly/build.gradle
tasks.register('depsJar', Jar) {
  inputs.files {
    configDeps  // <- a task defined elsewhere
  }
  description 'Assembles jar archive defining classpath.'
  archiveName 'geode-dependencies.jar'
  doFirst {
    manifest {
      attributes(
        "Class-Path":
             configDeps.outputs.files.singleFile.text)
    }
  }
}
  \end{lstlisting}
  \caption{Via syntactic sugar and closure delegation,
  a function \texttt{register} is invoked with three arguments: a String name, a class, and a closure.
  Within the context and from the delegate of that closure,
    the \texttt{doFirst} function takes another closure,
    the delegate of which can handle the \texttt{manifest} function call.
  And so on.}
  \label{snip:keywords}
\stopSnippetFig

\section{Gradle crash course}

\subsection{The root project, subprojects, and buildSrc}

Your Gradle build structures itself similar to your directory structure.
The build begins in some root directory containing a \texttt{build.gradle} and \texttt{settings.gradle} files.
This root directory corresponds to your \emph{root project} of the build.

In the \texttt{settings.gradle} file, you might indicate subdirectories that this build should \texttt{include}.
These directories become \emph{subprojects}.

In an ideal world, projects and subprojects are structured hierarchically,
 with shared resources required by multiple subprojects belonging to their nearest common ancestor.
While we rarely get to live in an ideal world, developers should do as much as they can to keep their builds modular and,
  barring full modularity, looking only upward.
When necessary, one subproject can refer to another simply by calling for it by it's colon-separated path, e.g. \texttt{project("path:to:some:subproject")}.
Be warned, however, that this can easily undermine the stability and correctness of your build, while also making configuration of either subproject more difficult.
(Build phases and configuration is discussed more below.)

Lastly, there is one special, optional "side project" -- the \texttt{buildSrc} project.
This project does not need to be called out in your \texttt{settings.gradle}, since it isn't intended as part of your project itself.
Rather, \texttt{buildSrc} will contain any special files that you need to build for the execution of the Gradle build itself.
For instance, if you have a custom class defining how testing should work, that class belongs to \texttt{buildSrc} subproject.
The \texttt{buildSrc} project is always built before your main build begins,%
\footnote{
  Or rather, if your \texttt{buildSrc} is relatively stable, it should more often get the required artifacts from the Gradle cache.
}
and so those classes will be available to your root project and subprojects as needed.


\subsection{The build in broadest of strokes - Tasks, the Task Graph, and Task I/O}

Things get done in Gradle by \emph{tasks}.
A task is essentially the atomic unit of work in Gradle.%
\footnote{This is not precisely accurate.
  The smallest cachable unit of work in Gradle is an \emph{action}.
  Most of the time, you won't need to deal with things at such a fine granularity.
  But if you explicitly declare out a \texttt{doFirst} or \texttt{doLast} block, you are registering additional actions to your task.
}
A task typically has some inputs, some outputs, and some task dependencies.

Every task is named.
When you invoke a build via \texttt{./gradlew build}, you are invoking the \texttt{:build} task that lives in the root project.
Often, this will require the building of each subproject, and these tasks are also named, with the colon-separated path prepended to the task name.
So when you run \texttt{./gradlew build}, you will run \texttt{:build} and also \texttt{:subProject:build} and \texttt{:subProject:deeperSubProject:build}

How does the initial \texttt{:build} task no to invoke those other tasks?
The task graph!

\subsection{Phases of a build}
The lifecycle of a build\footnote{See the docs: \url{https://docs.gradle.org/current/userguide/build_lifecycle.html}} consists of three main phases: Initialization, Configuration, and Execution.

The Initialization phase loads your \texttt{settings.gradle} to identify what subprojects and (in a multi-project build) what projects will been needed for this build.



\section{Advice for Gradle Users}

\subsection{Gradle gotchas}

\subsubsection{A task should depend on a task, not on a task.outputs.files}
Getting the files output by a task is not the same as getting the outputs directly.  For instance,
\begin{lstlisting}[language=Groovy]
tasks.register('myTask') {
  inputs.files { someOtherTask.outputs.files }
  // task configuration
}
\end{lstlisting}

does not imply a task dependency in the way that the following does.
\begin{lstlisting}[language=Groovy]
tasks.register('myTask') {
  inputs.files { someOtherTask }
  // task configuration
}
\end{lstlisting}

The former declares locations on disk as the input to a task, whereas the latter declares the output of a task as the input to another task.
Because Gradle builds incrementally and \texttt{inputs} are more concerned with changes than explicit content, the absence of these files is considered a valid input.
Depending directly on another task, as in the latter example, had additional safeguards that guarantee that a files are being produced for consumption.

\subsection{Gradle best practices and conventions}

\subsection{Gradle command line interactions}

\subsection{Important notes for consuming Geode via composite build}

\end{document}


