/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.apache.geode.gradle.plugins.jarcheck

import org.apache.geode.gradle.plugins.jarcheck.tasks.ListFileComparisonTask
import org.apache.geode.gradle.plugins.jarcheck.tasks.ExamineJarContentTask
import org.apache.geode.gradle.plugins.jarcheck.tasks.ExamineJarManifestClasspathTask
import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.tasks.Copy

import java.nio.file.Path
import java.nio.file.Paths

class JarCheckPlugin implements Plugin<Project> {

  static final String EXTENSION_NAME = "jarCheck"
  static final String ROOT_CHECK_TASK_NAME = "jarCheckAll"
  static final String ROOT_UPDATE_TASK_NAME = "jarCheckUpdateAll"

  static final String EXPECTATIONS_BUILD_DIR = "src/build-resources/jarCheckExpectations"

  JarCheckExtension extension

  Set<String> seenJarNamePieces = new HashSet<>()


  @Override
  void apply(Project project) {
    project.getPlugins().apply(BasePlugin.class)

    project.tasks.register(ROOT_CHECK_TASK_NAME) {
      description "This is a synthetic task to perform all jar checks configured with the JarCheck plugin."
    }

    project.tasks.register(ROOT_UPDATE_TASK_NAME) {
      description "This is a synthetic task to perform all jar expectation updates configured with the JarCheck plugin."
    }

    // setup the extension
    extension = project.getExtensions().create(EXTENSION_NAME, JarCheckExtension.class, project)

    project.afterEvaluate( {
      createTasks(project)
      hookIntoCheckIfRequested(project)
    } as Action<Project>)
  }

  static String jarFilenameToTaskName(File jarFile) {
    return jarFile.name.replaceAll(/(?i)\.jar$/, '').split(/[^a-zA-Z01-9]+/)*.capitalize().join("")
  }

  void hookIntoCheckIfRequested(Project project) {
    if (extension.makePartOfCheck) {
      project.tasks.named('check').configure {
        dependsOn project.tasks.named(ROOT_CHECK_TASK_NAME)
      }
    }
  }


  void createTasks(Project project) {
    if (extension.implicitlyCheckAll) {
      extension.checkAllJarTasks()
    }

    Path expectationDir = Paths.get("${project.projectDir}/${EXPECTATIONS_BUILD_DIR}")
    Path workingBuildDir = Paths.get("${project.buildDir}/${EXTENSION_NAME}")

    if (!expectationDir.toFile().exists()) {
      expectationDir.toFile().mkdirs()
    }
    extension.jarsToCheck.each { File jarFile, JarCheckConfiguration config ->
      String jarTaskNamePiece = jarFilenameToTaskName(jarFile)
      project.logger.debug("Creating check tasks for sanitized task name piece: ${jarTaskNamePiece}...")

      if (seenJarNamePieces.contains(jarTaskNamePiece)) {
        throw new IllegalArgumentException(
            "A jar with corresponding task name piece ${jarTaskNamePiece}" +
                " has already been registered for checking.  " +
                "Task names are generated by stripping non-alphanumeric characters and capitalizing.  " +
                "Tasks names cannot be inferred when similarly-named jars exist.  " +
                "Resolve this conflict or configure jar checking tasks directly.")
      }
      seenJarNamePieces.add(jarTaskNamePiece)

      if (config.checkContent) {
        project.logger.debug("Adding CONTENT checks for ${jarFile}")

        String examineContentTaskname = "examine${jarTaskNamePiece}Content"
        String checkContentTaskname = "check${jarTaskNamePiece}Content"
        String updateContentTaskname = "update${jarTaskNamePiece}ExpectedContent"

        File expectationFile = expectationDir.resolve("${jarTaskNamePiece}-content-expectation.txt").toFile()
        File actualFile = workingBuildDir.resolve("${jarTaskNamePiece}-content-actual.txt").toFile()
        File reportFile = workingBuildDir.resolve("${jarTaskNamePiece}-content-report.txt").toFile()

        if (!expectationFile.exists()) {
          project.logger.warn("Expected jar-check file '${expectationFile}' does not exist.  Run '${updateContentTaskname}' to initialize.")
          try {
            println "can write? [${expectationFile.parentFile.canWrite()}]"
            expectationFile.write("")
          } catch (IOException e) {
            project.logger.error("Could not initialize '${expectationFile}'.  Expect failures with message '... expectation does not exist.'")
          }
        }

        project.tasks.register(examineContentTaskname, ExamineJarContentTask) {
          checks jarFile
          outputFile = actualFile

          if (config.jarCreator != null) {
            inputs.files { config.jarCreator }
          }
        }

        project.tasks.register(updateContentTaskname, Copy) {
          from actualFile.parent
          into expectationFile.parent
          include actualFile.name
          rename actualFile.name, expectationFile.name

          inputs.files { project.tasks.named(examineContentTaskname) }
        }

        project.tasks.register(checkContentTaskname, ListFileComparisonTask) {
          actual = actualFile
          expectation = expectationFile
          report = reportFile
          correspondingUpdateTaskProvider = project.tasks.named(updateContentTaskname)

          inputs.files { project.tasks.named(examineContentTaskname) }
          inputs.files { expectationFile }
          mustRunAfter { project.tasks.named(updateContentTaskname) }
        }

        project.tasks.named(ROOT_CHECK_TASK_NAME).configure {
          dependsOn checkContentTaskname
        }
        project.tasks.named(ROOT_UPDATE_TASK_NAME).configure {
          dependsOn updateContentTaskname
        }
      }

      if (config.checkManifestClasspath) {
        project.logger.debug("Adding MANIFEST CLASSPATH checks for ${jarFile}")

        String examineManifestTaskname = "examine${jarTaskNamePiece}ManifestClasspath"
        String checkManifestTaskname = "check${jarTaskNamePiece}ManifestClasspath"
        String updateManifestTaskname = "update${jarTaskNamePiece}ExpectedManifestClasspath"

        File expectationFile = expectationDir.resolve("${jarTaskNamePiece}-manifest-classpath-expectation.txt").toFile()
        File actualFile = workingBuildDir.resolve("${jarTaskNamePiece}-manifest-classpath-actual.txt").toFile()
        File reportFile = workingBuildDir.resolve("${jarTaskNamePiece}-manifest-classpath-report.txt").toFile()

        if (!expectationFile.exists()) {
          project.logger.warn("Expected jar-check file '${expectationFile}' does not exist.  Run '${updateManifestTaskname}' to initialize.")
          try {
            println "can write? [${expectationFile.parentFile.canWrite()}]"
            expectationFile.write("")
          } catch (IOException e) {
            project.logger.error("Could not initialize '${expectationFile}'.  Expect failures with message '... expectation does not exist.'")
          }
        }


        project.tasks.register(examineManifestTaskname, ExamineJarManifestClasspathTask) {
          checks jarFile
          outputFile = actualFile

          if (config.jarCreator != null) {
            inputs.files { config.jarCreator }
          }
        }

        project.tasks.register(updateManifestTaskname, Copy) {
          from actualFile.parent
          into expectationFile.parent
          include actualFile.name
          rename actualFile.name, expectationFile.name

          inputs.files { project.tasks.named(examineManifestTaskname) }
        }

        project.tasks.register(checkManifestTaskname, ListFileComparisonTask) {
          actual = actualFile
          expectation = expectationFile
          report = reportFile
          correspondingUpdateTaskProvider = project.tasks.named(updateManifestTaskname)

          inputs.files { project.tasks.named(examineManifestTaskname) }
          inputs.files { expectationFile }
          mustRunAfter { project.tasks.named(updateManifestTaskname) }
        }

        project.tasks.named(ROOT_CHECK_TASK_NAME).configure {
          dependsOn checkManifestTaskname
        }
        project.tasks.named(ROOT_UPDATE_TASK_NAME).configure {
          dependsOn updateManifestTaskname
        }
      }
    }
  }
}
